{
    "contents" : "options(stringsAsFactors = FALSE)\n# Load data of spot and 1-month forward exchange rates\ndata = read.csv(\"proj15_spot_forward_exchange_rate.csv\")\n# Data setup\ncolnames(data) = c('date','AUD','AUD_f','JPY','JPY_f','GBP','GBP_f')\ndata$date = as.Date(data$date,\"%m/%d/%Y\")\n# Convert the quoted form to US dollar/currency\ndata[,2:5] = 1/data[,2:5]\n# Take logarithm\ndata[,2:7] = log(data[,2:7])\n\n# Extract spot and forward exchange rate\nspot = data.frame(date=data$date,AUD=data$AUD,JPY=data$JPY,GBP=data$GBP)\nforward = data.frame(date=data$date,AUD_f=data$AUD_f,JPY_f=data$JPY_f,GBP_f=data$GBP_f)\n\n# Plot log spot exchange rate\nplot(spot[,1:2],typ='l',ylab='AUD',main='Exchange Rate')\nplot(spot[,c(1,3)],typ='l',ylab='JPY',main='Exchange Rate')\nplot(spot[,c(1,4)],typ='l',ylab='GBP',main='Exchange Rate')\n\npar(mfrow=c(1,2))\n# ACF and PACF\nacf(spot$AUD);pacf(spot$AUD)\nacf(spot$JPY);pacf(spot$JPY)\nacf(spot$GBP);pacf(spot$GBP)\npar(mfrow=c(1,1))\n# ADF test\nlibrary(fUnitRoots)\nadfTest(spot$AUD,type=c(\"nc\"));adfTest(spot$JPY,type=c(\"nc\"));adfTest(spot$GBP,type=c(\"nc\"))\n\n# Extract data before 2013-07-01\nAUD_diff = diff(spot[spot$date<=\"2013-07-01\",2])\nJPY_diff = diff(spot[spot$date<=\"2013-07-01\",3])\nGBP_diff = diff(spot[spot$date<=\"2013-07-01\",4])\n\ndate = spot[spot$date<=\"2013-07-01\",1]\n\n# Plot log return of exchange rate\nplot(date[-1],AUD_diff,typ='l',ylab='AUD',main='Difference of Log Exchange Rate (AUD)')\nplot(JPY_diff,typ='l',ylab='JPY',main='Difference of Log Exchange Rate (JPY)')\nplot(GBP_diff,typ='l',ylab='GBP',main='Difference of Log Exchange Rate (GBP)')\n\n# ACF and PACF of log return of exchange rate\npar(mfrow=c(1,2))\nacf(AUD_diff,main='Log Return of Exchange Rate(AUD)');pacf(AUD_diff,main='Log Return of Exchange Rate(AUD)')\nacf(JPY_diff,main='Log Return of Exchange Rate(JPY)');pacf(JPY_diff,main='Log Return of Exchange Rate(JPY)')\nacf(GBP_diff,main='Log Return of Exchange Rate(GBP)');pacf(GBP_diff,main='Log Return of Exchange Rate(GBP)')\npar(mfrow=c(1,1))\n# ADF test after differencing ##(No unit root)\nadfTest(AUD_diff);adfTest(JPY_diff);adfTest(GBP_diff) \n\nhist(AUD_diff,breaks=20,ylab='Frequency',xlab='',main='Difference of Log Exchange Rate') \n\n\n#install.packages('TSA')\nlibrary(TSA)\n# Identify a good ARMA order using EACF\neacf(AUD_diff, ar.max = 8, ma.max = 8)\neacf(JPY_diff, ar.max = 8, ma.max = 8)\neacf(GBP_diff, ar.max = 8, ma.max = 8)\n\n## ARCH effect analysis\nt.test(AUD_diff)\nt.test(JPY_diff)\nt.test(GBP_diff)\n\n# ACF of diff and squared diff of log exchange rate\npar(mfrow=c(1,2))\nacf(AUD_diff,main='Log Return of Exchange Rate(AUD)',ylim=c(-0.2,0.4)) \nacf(AUD_diff^2,main='Squared Log Return of Exchange Rate(AUD)',ylim=c(-0.2,0.4)) \nacf(JPY_diff,main='Log Return of Exchange Rate(JPY)',ylim=c(-0.2,0.4)) \nacf(JPY_diff^2,main='Squared Log Return of Exchange Rate(JPY)',ylim=c(-0.2,0.4)) ## not too much dependence\nacf(GBP_diff,main='Difference of Exchange Rate(GBP)',ylim=c(-0.2,0.4)) \nacf(GBP_diff^2,main='Squared Log Return of Exchange Rate(GBP)',ylim=c(-0.2,0.4))  \npar(mfrow=c(1,1))\n\n# Ljung-Box test\nBox.test(AUD_diff,lag=12,type=(\"Ljung-Box\"))\nBox.test(AUD_diff^2,lag=12,type=(\"Ljung-Box\"))\nBox.test(JPY_diff,lag=12,type=(\"Ljung-Box\"))\nBox.test(JPY_diff^2,lag=12,type=(\"Ljung-Box\"))\nBox.test(GBP_diff,lag=12,type=(\"Ljung-Box\"))\nBox.test(GBP_diff^2,lag=12,type=(\"Ljung-Box\"))\n\nlibrary(fGarch)\n# Fit data into Garch(1,1), mean equation is a constant \nm1 = garchFit(~garch(1,1),data=AUD_diff,trace=F)\nm2 = garchFit(~garch(1,1),data=JPY_diff,trace=F)\nm3 = garchFit(~garch(1,1),data=GBP_diff,trace=F)\nsummary(m1);summary(m2);summary(m3)\n\nlibrary(rugarch)\n# IGARCH for AUD\nspec = ugarchspec(variance.model=list(model=\"iGARCH\",garchOrder=c(1,1)),\n                         mean.model=list(armaOrder=c(0,0))) # mean equation=constant\nm1_I = ugarchfit(spec=spec,data=AUD_diff)\nm1_I\n# APARCH\nm1_ap = garchFit(~1+aparch(1,1), data=AUD_diff, trace=F)\n\n# EGARCH for AUD\negarch11.spec = ugarchspec(variance.model=list(model=\"eGARCH\",garchOrder=c(1,1)),\n                           mean.model=list(armaOrder=c(0,0)))# mean equation=constant\nm1_E = ugarchfit(egarch11.spec,data= AUD_diff)\n#m2_E = ugarchfit(egarch11.spec,data= JPY_diff)\n#m3_E = ugarchfit(egarch11.spec,data= GBP_diff)\nsummary(m1_E)\n\nm1_ged = garchFit(~garch(1,1),data=AUD_diff,trace=F,cond.dist=c(\"ged\"))\nm2_ged = garchFit(~garch(1,1),data=JPY_diff,trace=F,cond.dist=c(\"ged\"))\nm3_ged = garchFit(~garch(1,1),data=GBP_diff,trace=F,cond.dist=c(\"ged\"))\nsummary(m1_ged);summary(m2_ged);summary(m3_ged)\n# In the case of AUD/US, alpha1 and beta1 are significant at the level 0.01\n# We think GARCH(1,1) model can be used to predcit log return of exchange rate\n\n\nm1_res = m1@residuals\nm1_res_std = m1@residuals/volatility(m1)\nm2_res = m2@residuals\nm2_res_std = m2@residuals/volatility(m2)\nm3_res = m3@residuals\nm3_res_std = m3@residuals/volatility(m3)\n\n# Observe volatility and log return of exchange rate \nplot(AUD_diff,typ='l',ylab='USD/AUD')\nlines(volatility(m1),col='red')\nlegend(160,0.1,c('log return of USD/AUD','volatility'),col=c(1,2),lwd=c(2,2))\n\n# ACFs \npar(mfrow=c(2,2)) \nacf(m1_res,main='Residual (AUD)',ylim=c(-0.1,0.5)) \nacf(m1_res^2,main='Residual Squared (AUD)',ylim=c(-0.1,0.5)) \nacf(m1_res_std,main='GARCH(1,1) Std Residual (AUD)',ylim=c(-0.1,0.5)) \nacf(m1_res_std^2,main='GARCH(1,1) Std Residual Squared (AUD)',ylim=c(-0.1,0.5)) \n\nacf(m2_res,main='Residual (JPY)',ylim=c(-0.15,0.5)) \nacf(m2_res^2,main='Residual Squared (JPY)',ylim=c(-0.15,0.5)) \nacf(m2_res_std,main='GARCH(1,1) Std Residual (JPY)',ylim=c(-0.15,0.5)) \nacf(m2_res_std^2,main='GARCH(1,1) Std Residual Squared (JPY)',ylim=c(-0.15,0.5)) \n\nacf(m3_res,main='Residual (GBP)',ylim=c(-0.1,0.5)) \nacf(m3_res^2,main='Residual Squared (GBP)',ylim=c(-0.1,0.5)) \nacf(m3_res_std,main='GARCH(1,1) Std Residual (GBP)',ylim=c(-0.1,0.5)) \nacf(m3_res_std^2,main='GARCH(1,1) Std Residual Squared (GBP)',ylim=c(-0.1,0.5)) \n\n# PACFs \npacf(m1_res,main='Residual (AUD)',ylim=c(-0.1,0.5)) \npacf(m1_res^2,main='Residual Squared (AUD)',ylim=c(-0.1,0.5)) \npacf(m1_res_std,main='GARCH(1,1) Std Residual (AUD)',ylim=c(-0.1,0.5)) \npacf(m1_res_std^2,main='GARCH(1,1) Std Residual Squared (AUD)',ylim=c(-0.1,0.5)) \n\npacf(m2_res,main='Residual (JPY)',ylim=c(-0.15,0.5)) \npacf(m2_res^2,main='Residual Squared (JPY)',ylim=c(-0.15,0.5)) \npacf(m2_res_std,main='GARCH(1,1) Std Residual (JPY)',ylim=c(-0.15,0.5)) \npacf(m2_res_std^2,main='GARCH(1,1) Std Residual Squared (JPY)',ylim=c(-0.15,0.5)) \n\npacf(m3_res,main='Residual (GBP)',ylim=c(-0.1,0.5)) \npacf(m3_res^2,main='Residual Squared (GBP)',ylim=c(-0.1,0.5)) \npacf(m3_res_std,main='GARCH(1,1) Std Residual (GBP)',ylim=c(-0.1,0.5)) \npacf(m3_res_std^2,main='GARCH(1,1) Std Residual Squared (GBP)',ylim=c(-0.1,0.5)) \n\npar(mfrow=c(1,1)) \nplot(m1_res_std,typ='l',ylab='',main='Standardized Residuals (AUD)')\nplot(m2_res_std,typ='l',ylab='',main='Standardized Residuals (JPY)')\nplot(m3_res_std,typ='l',ylab='',main='Standardized Residuals (GBP)')\n\nn = nrow(spot) # number of full data\nm = nrow(spot[spot$date<=\"2013-07-01\",]) \nrealized_return = as.data.frame(matrix(rep(0,(n-m)*3),nrow=n-m))\ncolnames(realized_return)=c('AUD','JPY','GBP')\ndata_temp=c()\nfor(j in 1:3)\n{\n  for (i in 1:(n-m))\n  {\n    data_temp = diff(spot[1:m-1+i,j+1])\n    mdl = garchFit(~garch(1,1),data=data_temp,trace=F)\n    pred = predict(mdl,n.ahead = 1)[,3] # predict the volatility of the next day\n    mdl_res_std = mdl@residuals/volatility(mdl)\n    epsilon = mdl_res_std[length(mdl_res_std)]\n    if (mdl@fit$coef[1]+pred * epsilon > (forward[m-1+i,j+1] - spot[m-1+i,j+1]))\n      realized_return[i,j] = spot[m+i,j+1] - forward[m-1+i,j+1]\n    else\n      realized_return[i,j] = forward[m-1+i,j+1] - spot[m+i,j+1]\n  }\n}\nrm(i,j,mdl,pred,epsilon,data_temp)\ncolMeans(realized_return, na.rm = FALSE, dims = 1)\n\n\n# Using Generalized Error as underlying distributions of epsilon_t\nrealized_return_ged = as.data.frame(matrix(rep(0,(n-m)*3),nrow=n-m))\ncolnames(realized_return_ged)=c('AUD','JPY','GBP')\ndata_temp=c()\n\nfor(j in 1:3)\n{\n  for (i in 1:(n-m))\n  {\n    data_temp = diff(spot[1:m-1+i,j+1])\n    mdl = garchFit(~garch(1,1),data=data_temp,trace=F,cond.dist=c(\"ged\"))\n    pred = predict(mdl,n.ahead = 1)[,3] # predict the volatility of the next day\n    mdl_res_std = mdl@residuals/volatility(mdl)\n    epsilon = sample(mdl_res_std, 1, replace = TRUE)\n    if (mdl@fit$coef[1]+pred * epsilon > (forward[m-1+i,j+1] - spot[m-1+i,j+1]))\n      realized_return_ged[i,j] = spot[m+i,j+1] - forward[m-1+i,j+1]\n    else\n      realized_return_ged[i,j] = forward[m-1+i,j+1] - spot[m+i,j+1]\n  }\n} \nrm(i,j,mdl,pred,epsilon,data_temp)\n\n# OLS methods \nrealized_return_ols = as.data.frame(matrix(rep(0,(n-m)*3),nrow=n-m))\ncolnames(realized_return_ols)=c('AUD','JPY','GBP')\nalpha_temp = c()\nbeta_temp = c()\nfor(j in 1:3)\n{\n  for (i in 1:(n-m))\n  {\n    y = diff(spot[1:(m-1+i),j+1])\n    X = forward[1:(m-2+i),j+1]-spot[1:(m-2+i),j+1] \n    mdl = lm(y~X)\n    if (mdl$coefficients[1]+ mdl$coefficients[2]*((forward[m-1+i,j+1] - spot[m-1+i,j+1]))> (forward[m-1+i,j+1] - spot[m-1+i,j+1]))\n      realized_return_ols[i,j] = spot[m+i,j+1] - forward[m-1+i,j+1]\n    else\n      realized_return_ols[i,j] = forward[m-1+i,j+1] - spot[m+i,j+1]\n  }\n}\nrm(i,j,y,X,b)\ncolMeans(realized_return_ols, na.rm = FALSE, dims = 1)\n\n## IGARCH\n#install.packages(\"rugarch\")\nlibrary(rugarch)\nrealized_return_AUD = c()\nfor (i in 1:(n-m))\n{\n  data_temp = diff(spot[1:m-1+i,2])\n  spec = ugarchspec(variance.model=list(model=\"iGARCH\",garchOrder=c(1,1)),\n                    mean.model=list(armaOrder=c(0,0))) # mean equation=constant\n  mdl = ugarchfit(spec=spec,data=data_temp)\n  # standardized residuals\n  residual_std = mdl@fit$residuals/mdl@fit$sigma\n  # predict the volatility of the next day\n  pred1 = as.numeric(sqrt(mdl@fit$coef[2]+mdl@fit$coef[3]*mdl@fit$residuals[length(mdl@fit$residuals)]^2\n                    +mdl@fit$coef[4]*mdl@fit$sigma[length(mdl@fit$sigma)]^2))\n  # select the last standardized residual as the next one \n  epsilon = residual_std[length(residual_std)]\n  # sample(residual_std,size=1,replace=TRUE)\n  if (mdl@fit$coef[1]+pred1 * epsilon > (forward[m-1+i,2] - spot[m-1+i,2]))\n    realized_return_AUD[i] = spot[m+i,2] - forward[m-1+i,2]\n  else\n    realized_return_AUD[i] = forward[m-1+i,2] - spot[m+i,2]\n  \n}\nrm(spec,mdl,residual_std,pred1,epsilon)\nrealized_return_AUD = data.frame(rtn = realized_return_AUD)\nmean(realized_return_AUD$rtn)\n\n# Relevant measures\nTB = read.csv(\"TB30.csv\")\nSP500 = read.csv(\"sp500.csv\")\nTB30 = cbind(TB[,2],TB[,2],TB[,2])\nexcess_return_3 =  realized_return-TB30\nexcess_return_mkt = SP500[,2] - TB[,2]\nexcess_return_aud = realized_return_AUD$rtn-TB$t30ret\ncolMeans(excess_return_3, na.rm = FALSE, dims = 1)\n\n#t.test(excess_return_3[,1],mu=0)\n#t.test(excess_return_3[,2],mu=0)\n#t.test(excess_return_3[,3],mu=0)\n\nsharpe_ratio_aud = mean(excess_return_3$AUD) /sd(excess_return_3$AUD)\nsharpe_ratio_jpy = mean(excess_return_3$JPY) /sd(excess_return_3$JPY)\nsharpe_ratio_gbp = mean(excess_return_3$GBP) /sd(excess_return_3$GBP)\nsharpe_ratio_mkt = mean(excess_return_mkt) /sd(excess_return_mkt)\nsharpe_ratio_aud_igarch = mean(excess_return_aud) /sd(excess_return_aud)\ncat('Sharpe Ratios:',sharpe_ratio_aud,sharpe_ratio_jpy,sharpe_ratio_gbp)\n# Count the winning months\nwin = c(sum(realized_return$AUD>0),sum(realized_return$JPY>0),sum(realized_return$GBP>0))\nsum(realized_return_AUD$rtn>0)\n# Count the lsoing months\nlose = c(sum(realized_return$AUD<0),sum(realized_return$JPY<0),sum(realized_return$GBP<0))\nsum(realized_return_AUD$rtn<0)\ncat('USD/AUD',sharpe_ratio_aud,'USD/JPY',sharpe_ratio_jpy,'USD/GBP',sharpe_ratio_gbp,'MARKET',sharpe_ratio_mkt)\n# Plot realized returns of GARCH(1,1) and OLS\npar(mfrow=c(3,1))\nplot(realized_return[,1],type='l',xlab='month',\n     ylab='Return of AUD',col='red',main='Return comparison of GARCH(1,1) and OLS')\nlines(realized_return_ols[,1],type='l',col='blue')\nlegend(10,0.045,c('GARCH','OLS'),col=c(2,4),lwd=c(2,2),bty='n',cex=1)\nplot(realized_return[,2],type='l',xlab='month',\n     ylab='Return of JPY',col='red',main='Return comparison of GARCH(1,1) and OLS')\nlines(realized_return_ols[,2],type='l',col='blue')\nlegend(10,0.045,c('GARCH','OLS'),col=c(2,4),lwd=c(2,2),bty='n',cex=1)\nplot(realized_return[,3],type='l',xlab='month',\n     ylab='Return of GBP',col='red',main='Return comparison of GARCH(1,1) and OLS')\nlines(realized_return_ols[,3],type='l',col='blue')\nlegend(10,0.045,c('GARCH','OLS'),col=c(2,4),lwd=c(2,2),bty='n',cex=1)\npar(mfrow=c(1,1))\n\n## daily data\ndata_daily = read.csv(\"proj15_daily_exchange_rate.csv\")\n\n# Data setup\ndata_daily = data_daily[!is.na(data_daily[,2]),1:4]\ncolnames(data_daily) = c('date','AUD','JPY','GBP')\ndata_daily$date = as.Date(data_daily$date,\"%d-%B-%y\")\n\ndata_daily[,2:4] = 1/data_daily[,2:4]\n\ndata_daily[,2:4]=log(data_daily[,2:4])\n\n# Extract data before 2013-07-01\nAUD_diff = diff(data_daily[data_daily$date<=\"2013-07-01\",2])\nJPY_diff = diff(data_daily[data_daily$date<=\"2013-07-01\",3])\nGBP_diff = diff(data_daily[data_daily$date<=\"2013-07-01\",4])\n\nplot(AUD_diff,typ='l',ylab='',main='AUD/US')\nplot(JPY_diff,typ='l',ylab='',main='JPY/US')\nplot(GBP_diff,typ='l',ylab='',main='GBP/US')\n\neacf(AUD_diff)\n\nlibrary(rugarch)\negarch11.spec = ugarchspec(variance.model=list(model=\"eGARCH\",garchOrder=c(1,1)),\n                           mean.model=list(armaOrder=c(0,0)))# mean equation=constant\nm1_E = ugarchfit(egarch11.spec,data= AUD_diff)\nm2_E = ugarchfit(egarch11.spec,data= JPY_diff)\nm3_E = ugarchfit(egarch11.spec,data= GBP_diff)\nlibrary(fGarch)\nm1_ap = garchFit(~1+aparch(1,1), data=AUD_diff, trace=F)\nm2_ap = garchFit(~1+aparch(1,1), data=JPY_diff, trace=F)\nm3_ap = garchFit(~1+aparch(1,1), data=GBP_diff, trace=F)\nresidual_m1_E = m1_E@fit$residuals\nstd_residual_m1_E=m1_E@fit$residuals/m1_E@fit$sigma\nplot(std_residual_m1_E,typ='l',ylab='Standardized Residuals')\npar(mfrow=c(2,2))\nacf(residual_m1_E,main='Residual');acf(residual_m1_E^2,main='Squared Residual')\nacf(std_residual_m1_E,main='EGARCH(1,1) Standardized Residual');acf(std_residual_m1_E^2,main='EGARCH(1,1) Squared Standardized Residual')\nBox.test(m1_E@fit$residuals,lag=12,type=(\"Ljung-Box\"))\nBox.test(std_residual_m1_E^2,lag=12,type=(\"Ljung-Box\"))\n\n\n",
    "created" : 1431093265237.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "1023246177",
    "id" : "880DD9F6",
    "lastKnownWriteTime" : 1431575015,
    "path" : "C:/Users/Chang Yen-hsiu/Desktop/Second Semester/Financial Time Series/proj15/proj15.r",
    "project_path" : "proj15.r",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}